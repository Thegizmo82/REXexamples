/*******************************************************
*                                                      *
*   REXLANG example - data exchange via serial line    *
*                                                      *
*   Sender station                                     *
*                                                      *
*   (c) REX Controls, www.rexcontrols.com              *
*                                                      *
*******************************************************/

#define CON_COM1 33	       // COM1 in Windows, /dev/ttyS1 in Linux
#define CON_COM2 34
#define CON_COM3 35
#define CON_COM4 36
#define CON_COM5 37        // COM5 in Windows, /dev/ttyS5 in Linux
#define CON_COM6 38
#define CON_COM7 39
#define CON_COM8 40
#define CON_COM9 41        // COM9 in Windows, /dev/ttyS9 in Linux
#define CON_COM_FNAME 63   // serial device defined by the fname parameter

#define COM_BAUDRATE 57600 //baudrate, e.g. 9600, 19200, 57600, 115200
#define COM_PARITY 0       //parity, 0=none

#define BUFFER_SIZE  50    //maximum number of bytes to send

long input(0) signal0;     //integer number to send to the receiver
long input(1) signal1;     //integer number to send to the receiver
double input(2) signal2;   //real number to send to the receiver
double input(3) signal3;   //real number to send to the receiver
long output(15) handle;    //handle of the serial device

long hCom;                 //communication handle
long buffer[BUFFER_SIZE];  //buffer for incoming data
long dataCnt;              //number of bytes sent
long convData[2];          //array for data conversion

/* Function for conversion of decimal number (the val parameter) to 2 numbers 
of type long (i.e. 8 bytes) representing the number in the double format 
according to IEEE 754. Little-endian format is used. */
void DoubleAsLong(double val, long ares[])
{
	double rmax=pow(2.0,1022.0);
	long lexp=0, i;

	ares[0]=0; ares[1]=0;
	if(val<0)
	{
		ares[1]=0x80000000;
		val=-val;
	}
	if(val<1.0/rmax)
		return; //zero
	if(val>=1.0)
	{
		for(i=9;i>=0;--i)
		{
			rmax=pow(2.0,(double)(1<<i));
			if(val>=rmax)
			{
				val/=rmax;
				lexp+=(1<<i);
			}
		}
		ares[1] = ares[1] | ((1023+lexp)<<20);
	}
	else
	{
		for(i=9;i>=0;--i)
		{
			rmax=pow(2.0,(double)(-(1<<i)));
			if(val<2.0*rmax)
			{
				val/=rmax;
				lexp+=(1<<i);
			}
		}
		ares[1] = ares[1]|((1023-lexp)<<20);
	}
	
	val=(val-1.0)*((double)0x00100000);
	ares[1] = ares[1]|(i=(long)val);
	ares[0] = (long)((val-i)*pow(2.0,32.0));
}

/* Initialization of the REXLANG algorithm */
int init(void)
{
  hCom = -1;
	return 0;
}

/* The body of REXLANG algorithm */
int main(void)
{
  if (hCom<0)
  {
    hCom = Open(CON_COM5,COM_BAUDRATE,COM_PARITY);  //opening serial device
  }
  else 
  {
    //signal 0 is of type long, therefore 4 bytes of data
    buffer[0] = signal0;
    buffer[1] = signal0 >> 8;
    buffer[2] = signal0 >> 16;
    buffer[3] = signal0 >> 24;
    //signal 1 is just a binary signal, therefore 1 byte
    buffer[4] = signal1;
    //signal 2 is of type double, therefore we convert it to 8 bytes
    DoubleAsLong(signal2,convData);
    buffer[5] = convData[0];
    buffer[6] = convData[0] >> 8;
    buffer[7] = convData[0] >> 16;
    buffer[8] = convData[0] >> 24;
    buffer[9] = convData[1];
    buffer[10] = convData[1] >> 8;
    buffer[11] = convData[1] >> 16;
    buffer[12] = convData[1] >> 24 ;
    //signal 3 is of type double, therefore we convert it to 8 bytes
    DoubleAsLong(signal3,convData);
    buffer[13] = convData[0];
    buffer[14] = convData[0] >> 8;
    buffer[15] = convData[0] >> 16;
    buffer[16] = convData[0] >> 24;
    buffer[17] = convData[1];
    buffer[18] = convData[1] >> 8;
    buffer[19] = convData[1] >> 16;
    buffer[20] = convData[1] >> 24;
    //now all the data can be sent
    dataCnt = Send(hCom,buffer,20); //send data, number of bytes = 20
  }  
  handle = hCom;
  return 0;
}

/* Closing the REXLANG algorithm */
int exit(void)
{
	if(hCom>=0) Close(hCom);
  return 0;
}