long output(0) value1;
long output(1) value2;
long output(2) value3;
double output(10) value10;

long input(0) trigger;

long parameter(0) addr;

long trigger_1;

long hCom;
long buf[30];
long buf2[30];

#define SPIDEV_FNAME 71 // SPI device is defined by the fname parameter of the REXLANG block (e.g. set it to /dev/spidev0.0 on the Raspberry Pi minicomputer) )

int init(void)
{
	int res;

	hCom = Open(SPIDEV_FNAME);
	
	Trace(99, hCom);

	if(hCom >= 0)
	{
		buf2[0] = 0;
		buf2[1] = 8;
		buf2[2] = 1000000;
		SetOptions(hCom, buf2);

		GetOptions(hCom, buf);

		//Set SPI data mode
		//	SPI_MODE0 = 0,  // CPOL = 0, CPHA = 0, Clock idle low, data is clocked in on rising edge, output data (change) on falling edge
		//	SPI_MODE1 = 1,  // CPOL = 0, CPHA = 1, Clock idle low, data is clocked in on falling edge, output data (change) on rising edge
		//	SPI_MODE2 = 2,  // CPOL = 1, CPHA = 0, Clock idle high, data is clocked in on falling edge, output data (change) on rising edge
		//	SPI_MODE3 = 3,  // CPOL = 1, CPHA = 1, Clock idle high, data is clocked in on rising, edge output data (change) on falling edge

		Trace(0, buf[0]);  //	SPI mode (0-3 mode, | 4=CS_HIGH | 8=LSB_FIRST | 16=3WIRE | 32=LOOP | 64=NO_CS | 128=READY)
		Trace(1, buf[1]);  //	bits per word
		Trace(2, buf[2]);  //	max frequency
	}


	return 0;
}

int main(void)
{
  int res;
  
  if(trigger == 1 && trigger_1 == 0) {

		Trace(100,1);
  
  		buf[0] = 10; buf[1] = 3; buf[2] = 0x72;
		res = SPI(hCom, 0, buf, 3, buf2, 3);

    value1 = buf2[0];
    value2 = buf2[1];
    value3 = buf2[2];
    
		if(res>=0)
		{
			Trace(10,buf2[0]);
			Trace(11,buf2[1]);
			Trace(12,buf2[2]);
		}
    
  }
  trigger_1 = trigger;

  return 0;
}
